#排序


[十大经典排序算法总结（JavaScript描述）](https://juejin.im/post/57dcd394a22b9d00610c5ec8) 






稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
内排序：所有排序操作都在内存中完成；
外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
时间复杂度: 一个算法执行所耗费的时间。
空间复杂度: 运行完一个程序所需内存的大小。

![Alt](../images/on.png)


###1.冒泡排序（Bubble Sort）

###时间复杂度O（n*2）空间复杂度O（1）
###JS实现
```javascript
// 基础实现
 function bubbleSort(arr){
    for(let i = 1;i < arr.length;i++)
    {
        for(let j = 0;j < arr.length - i;j++){
        
            if(arr[j]>arr[j+1])
            {
                [arr[j],arr[j+1]] = [arr[j+1],arr[j]];
            }
        }
    }
    return arr;
}

var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort(arr))
```

```javascript
// 升级版，改进后的冒泡排序，设置标志位pos,标志位之后的为有序序列，不需要再进行比较
function bubbleSort2(arr){
    for(let i = 1;i < arr.length;i++)
    {
        var pos = arr.length-i;
        for(let j = 0;j < pos;j++){
        
            if(arr[j]>arr[j+1])
            {
                 pos = j;
                [arr[j],arr[j+1]] = [arr[j+1],arr[j]];
            }
        }
    }
    return arr;
}

var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort2(arr))
```

###2.选择排序（Selection Sort）


###时间复杂度O（n*2）空间复杂度O（1）

在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
##JS实现
```javascript

function  selectionSort(arr){
    for(let i =0;i<arr.length-1;i++)
    {
        var minindex = i;
        for(let j = i+1;j<arr.length;j++)
        {
            if(arr[minindex]>arr[j]){
                minindex = j;
            }
        }
        [arr[minindex],arr[i]] = [arr[i],arr[minindex]];
    }
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];

console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]

```

###3.直接插入排序（（Insertion Sort）


###时间复杂度O（n*2）空间复杂度O（1）

扑克牌原理，类似从小到大整牌的过程
##JS实现
```javascript

function  InsertionSort(arr){
    for (var i = 1; i < arr.length; i++) {
            var key = arr[i];
            var j = i - 1;
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
        return arr;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];

console.log(InsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]

```

###3.希尔排序（Shell Sort）


###时间复杂度O（n*lg(n)）空间复杂度O（1）
##JS实现
```javascript


```


###4.快速排序（Quick Sort）


###时间复杂度O（n*lg(n)）空间复杂度O（lg(n)）
##JS实现
```javascript
var quickSort2 = function(arr) {
    console.time('2.快速排序耗时');
　　if (arr.length <= 1) { return arr; }
　　var pivotIndex = Math.floor(arr.length / 2);
　　var pivot = arr.splice(pivotIndex, 1)[0];
　　var left = [];
　　var right = [];
　　for (var i = 0; i < arr.length; i++){
　　　　if (arr[i] < pivot) {
　　　　　　left.push(arr[i]);
　　　　} else {
　　　　　　right.push(arr[i]);
　　　　}
　　}
console.timeEnd('2.快速排序耗时');
　　return quickSort2(left).concat([pivot], quickSort2(right));
};

```

#栈

```javascript

function Stack(){
    var items = [];
    this.push = (ele)=>{ return items.push(ele)}//进栈
    this.pop = ()=>{return items.pop()}//出栈
    this.isEmpty = ()=>{return items.length==0?true:false} 
    this.size = ()=>{return items.length}
    this.clear =()=>{items.length=0}
    this.print = ()=>{console.log(items.toString())}
}
```
**利用栈实现进制转换**
```javascript

    function Stack(){
        var items = [];
        this.push = (ele)=>{items.push(ele)}//进栈
        this.pop = ()=>{return items.pop()}//出栈
        this.isEmpty = ()=>{return items.length==0?true:false} 
        this.size = ()=>{return items.length}
        this.clear =()=>{items.length=0}
        this.print = ()=>{console.log(items.toString())}
    }

    function divideBy2(decNumber)
    {
    var stack = new Stack(),
        binaryString = '';
        while(decNumber>0){
            stack.push(decNumber%2);
            decNumber=Math.floor(decNumber/2);
        }
        while(!stack.isEmpty()){
            binaryString += stack.pop();
        }
        console.log(binaryString)
    }

    divideBy2(10)

```


#队列

```javascript

function Queue(){
    var items = [];
    this.enqueue= ele=>{items.push(ele)}//队尾入队
    this.dequeue = ()=>items.shift()//对头出队
    this.isEmpty = ()=>items.length==0?true:false
    this.clear = ()=>{items.length=0};
    this.size = ()=>items.length;
    this.print = ()=>{console.log(items.toString())}
}


```
#链表

##单向链表
```javascript
 
 function Link(){
    var Node = function(ele){
        this.ele = ele;
        this.next=null;
    }
    var length = 0;
    var head = null;
    
    this.append = (ele)=>{
        //俩种可能，若链表为空，则追加的是链表的第一个元素，若不为空，直接追加元素
        var node = new Node(ele);
        var current;
        if(head==null){
            head = node;
        }else{
            current = head;
            while(current.next){
                current = current.next;
            }
            current.next = node;
        }
        length++;
    };//链表尾部追加元素



    this.insert = (ele,index)=>{
        var node = new Node(ele);
        var pre;
        pre = head;
        while(index>1){
            pre = pre.next;
        }
        node.next =  pre.next;
        pre.next = node;
        length++;
    };//向指定位置插入元素


    this.removeAt = (index)=>{
        if(index>-1 && index<length){
            var pre;
            var current;
            var de;
           if(index==0){
               de = head;
               head = head.next;
              
           }else{
            pre=head;
               while(index>1){
                pre=pre.next;
                index--;
               }
               current= pre.next;
               de = current;
               pre.next=current.next;
             
               
           }
           length--;
           return de.ele;
        }else{
            return 'error'
        }
    }//移除指定位置元素


    this.remove = ()=>{
        var pre = head;
        while(pre.next.next){
            
            pre=pre.next;
        }
        var ele2 = pre.next.ele;
        pre.next=null;

        length--;
        return ele2;
    };//移除尾元素
    this.indexOf = ()=>{};
    this.isEmpty = ()=>length==0?true:false;
    this.size = ()=>length;
    this.print = ()=>{
        var current;
        current=head;
        var str = '';
        while(current){
            str+=current.ele+' ';
            current=current.next;
        }
        console.log(str)
    };
}

```

##双向链表